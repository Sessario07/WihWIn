#!/usr/bin/env bash
# File: nginx/test_nginx.conf
# Purpose: Run validations against nginx/nginx.conf and show PASS/FAIL per check.
# Usage: chmod +x nginx/test_nginx.conf && ./nginx/test_nginx.conf
# Example k6 stress test (outside this script):
#   k6 run --vus 200 --duration 30s script.js
#   or with stages:
#   k6 run --vus 1000 --duration 60s script.js
set -euo pipefail

CONFIG_PATH="./nginx/nginx.conf"
FULL_PATH="$(pwd)/${CONFIG_PATH#./}"

fail_count=0
pass() { printf "PASS: %s\n" "$1"; }
fail() { printf "FAIL: %s\n" "$1"; fail_count=$((fail_count+1)); }

# helper: check file exists
if [ ! -f "$CONFIG_PATH" ]; then
    echo "ERROR: config file not found at $CONFIG_PATH"
    exit 2
fi

echo "Validating nginx config file: $CONFIG_PATH"
echo

# 1) If nginx binary exists, run syntax check
if command -v nginx >/dev/null 2>&1; then
    if nginx -t -c "$FULL_PATH" >/dev/null 2>&1; then
        pass "nginx -t syntax check"
    else
        # capture output for debugging
        nginx -t -c "$FULL_PATH" || true
        fail "nginx -t reported errors"
    fi
else
    echo "nginx binary not found in PATH â€” skipping nginx -t. Falling back to static checks."
fi

# helper to grep presence (simple, resilient to spaces)
has_directive() {
    local pattern="$1"
    grep -E -q "$pattern" "$CONFIG_PATH"
}

# 2) Basic global directives
has_directive 'worker_processes[[:space:]]+auto;'
&& pass "worker_processes auto present" || fail "worker_processes auto missing"

has_directive 'worker_connections[[:space:]]+10000;'
&& pass "events.worker_connections 10000 present" || fail "events.worker_connections 10000 missing"

has_directive 'multi_accept[[:space:]]+on;'
&& pass "events.multi_accept on present" || fail "events.multi_accept on missing"

# 3) HTTP tuning directives
for d in sendfile\ on; tcp_nopush\ on; tcp_nodelay\ on; keepalive_timeout\ 65; keepalive_requests\ 10000; ; do
    pattern="${d}"
    if has_directive "$pattern"; then
        pass "http directive: $pattern"
    else
        fail "http directive missing: $pattern"
    fi
done

# 4) Buffer sizes and timeouts
for d in "client_body_buffer_size[[:space:]]+128k;" "client_max_body_size[[:space:]]+10m;" "proxy_buffer_size[[:space:]]+128k;" "proxy_buffers[[:space:]]+4[[:space:]]+256k;" "proxy_busy_buffers_size[[:space:]]+256k;" ; do
    if has_directive "$d"; then
        pass "buffer setting present: $d"
    else
        fail "buffer setting missing: $d"
    fi
done

for d in "proxy_connect_timeout[[:space:]]+60s;" "proxy_send_timeout[[:space:]]+60s;" "proxy_read_timeout[[:space:]]+60s;"; do
    if has_directive "$d"; then
        pass "proxy timeout present: $d"
    else
        fail "proxy timeout missing: $d"
    fi
done

# 5) Rate limiting and connection limiting zones
has_directive 'limit_req_zone[[:space:]]+\$server_name[[:space:]]+zone=api_limit:10m[[:space:]]+rate=10000r/s;'
&& pass "limit_req_zone api_limit with rate 10000r/s present" || fail "limit_req_zone api_limit or rate missing"

has_directive 'limit_conn_zone[[:space:]]+\$server_name[[:space:]]+zone=conn_limit:10m;'
&& pass "limit_conn_zone conn_limit present" || fail "limit_conn_zone conn_limit missing"

has_directive 'limit_req_status[[:space:]]+429;'
&& pass "limit_req_status 429 present" || fail "limit_req_status 429 missing"

# 6) Upstreams
if grep -E -q 'upstream[[:space:]]+spring_backend[[:space:]]*\{' "$CONFIG_PATH"; then
    pass "upstream spring_backend present"
    if grep -A4 -E 'upstream[[:space:]]+spring_backend[[:space:]]*\{' "$CONFIG_PATH" | grep -q 'keepalive[[:space:]]+100;'; then
        pass "spring_backend keepalive 100 present"
    else
        fail "spring_backend keepalive 100 missing"
    fi
else
    fail "upstream spring_backend missing"
fi

if grep -E -q 'upstream[[:space:]]+fastapi_backend[[:space:]]*\{' "$CONFIG_PATH"; then
    pass "upstream fastapi_backend present"
    if grep -A4 -E 'upstream[[:space:]]+fastapi_backend[[:space:]]*\{' "$CONFIG_PATH" | grep -q 'keepalive[[:space:]]+100;'; then
        pass "fastapi_backend keepalive 100 present"
    else
        fail "fastapi_backend keepalive 100 missing"
    fi
else
    fail "upstream fastapi_backend missing"
fi

# 7) Server block basics
if grep -E -q 'server[[:space:]]*\{' "$CONFIG_PATH"; then
    pass "server block present"
else
    fail "server block missing"
fi

has_directive 'listen[[:space:]]+80'
&& pass "server listens on 80" || fail "server.listen 80 missing"

has_directive 'limit_conn[[:space:]]+conn_limit[[:space:]]+10000;'
&& pass "limit_conn conn_limit 10000 present" || fail "limit_conn conn_limit 10000 missing"

# 8) Location blocks and expected directives
check_location() {
    local loc="$1"
    local expected="$2"
    # extract location block snippet
    snippet=$(awk "/location[[:space:]]+${loc}/, /\\}/" "$CONFIG_PATH" 2>/dev/null || true)
    if [ -z "$snippet" ]; then
        fail "location ${loc} missing"
        return
    fi
    pass "location ${loc} present"
    # check expected tokens
    while read -r token; do
        if echo "$snippet" | grep -q -E "$token"; then
            pass "  ${loc}: contains ${token}"
        else
            fail "  ${loc}: missing ${token}"
        fi
    done <<< "$expected"
}

check_location "/api/spring/" $'limit_req[[:space:]]+zone=api_limit' $'rewrite[[:space:]]+\\^/api/spring/\\(.*\\)\\s+/\\$1\\s+break;' $'proxy_pass[[:space:]]+http://spring_backend;'
check_location "/api/fast/" $'limit_req[[:space:]]+zone=api_limit' $'rewrite[[:space:]]+\\^/api/fast/\\(.*\\)\\s+/\\$1\\s+break;' $'proxy_pass[[:space:]]+http://fastapi_backend;'

# health location: return 200 'OK' and content-type header
snippet_health=$(awk "/location[[:space:]]+\\/health/, /\\}/" "$CONFIG_PATH" 2>/dev/null || true)
if [ -z "$snippet_health" ]; then
    fail "location /health missing"
else
    pass "location /health present"
    if echo "$snippet_health" | grep -q "return[[:space:]]\+200[[:space:]]\+'OK'"; then
        pass "/health returns 200 'OK'"
    else
        fail "/health return 200 'OK' missing"
    fi
    if echo "$snippet_health" | grep -q "add_header[[:space:]]+Content-Type[[:space:]]+text/plain"; then
        pass "/health adds Content-Type text/plain"
    else
        fail "/health add_header Content-Type text/plain missing"
    fi
fi

# 9) Proxy header checks (basic presence anywhere in file)
for hdr in 'proxy_set_header[[:space:]]+Connection' 'proxy_set_header[[:space:]]+Host[[:space:]]+\$host' 'proxy_set_header[[:space:]]+X-Real-IP[[:space:]]+\$remote_addr' 'proxy_set_header[[:space:]]+X-Forwarded-For[[:space:]]+\$proxy_add_x_forwarded_for' 'proxy_set_header[[:space:]]+X-Forwarded-Proto[[:space:]]+\$scheme'; do
    if has_directive "$hdr"; then
        pass "proxy header present: $hdr"
    else
        fail "proxy header missing: $hdr"
    fi
done

# Summary
echo
if [ "$fail_count" -eq 0 ]; then
    echo "All checks passed: $fail_count failures."
    exit 0
else
    echo "Checks completed: $fail_count failure(s) detected."
    exit 1
fi